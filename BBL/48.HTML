<!doctype html>
<html lang="zh-CN">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>48.glb - Babylon.js 旋转展示</title>
		<style>
			html,
			body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				overflow: hidden;
				background: #0b0f19;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
				display: block;
			}

			#hud {
				position: fixed;
				top: 12px;
				left: 12px;
				z-index: 10;
				color: #e8eefc;
				font: 12px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
					"Helvetica Neue", Arial;
				background: rgba(10, 12, 18, 0.72);
				backdrop-filter: blur(6px);
				border: 1px solid rgba(255, 255, 255, 0.08);
				border-radius: 10px;
				padding: 10px 12px;
				min-width: 260px;
				user-select: none;
			}

			#hud .row {
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 10px;
				margin: 6px 0;
			}

			#hud label {
				opacity: 0.9;
				white-space: nowrap;
			}

			#hud input[type="range"] {
				width: 150px;
			}

			#status {
				opacity: 0.85;
				margin-top: 6px;
				font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
					"Liberation Mono", "Courier New", monospace;
			}

			#hint {
				opacity: 0.7;
				margin-top: 6px;
			}
		</style>
	</head>
	<body>
		<div id="hud">
			<div class="row">
				<strong>48.glb 展示</strong>
				<span id="fps">-- fps</span>
			</div>
			<div class="row">
				<label><input id="rotateToggle" type="checkbox" checked /> 自转</label>
				<input id="rotateSpeed" type="range" min="0" max="2.5" step="0.01" value="0.55" />
			</div>
			<div class="row">
				<label><input id="fiberToggle" type="checkbox" checked /> 光纤变色</label>
				<input id="fiberSpeed" type="range" min="0" max="3" step="0.01" value="1.0" />
			</div>
			<div id="status">准备中…</div>
			<div id="hint">提示：若直接双击打开加载失败，请用本地服务器打开（见下）。</div>
		</div>
		<canvas id="renderCanvas"></canvas>

		<!-- Babylon.js CDN（静态网页可直接用） -->
		<script src="https://cdn.babylonjs.com/babylon.js"></script>
		<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

		<script>
			(function () {
				const canvas = document.getElementById("renderCanvas");
				const statusEl = document.getElementById("status");
				const fpsEl = document.getElementById("fps");

				const rotateToggle = document.getElementById("rotateToggle");
				const rotateSpeedEl = document.getElementById("rotateSpeed");
				const fiberToggle = document.getElementById("fiberToggle");
				const fiberSpeedEl = document.getElementById("fiberSpeed");

				const engine = new BABYLON.Engine(canvas, true, {
					preserveDrawingBuffer: true,
					stencil: true,
					disableWebGL2Support: false,
				});

				function setStatus(text) {
					statusEl.textContent = text;
				}

				function hsvToColor3(h, s, v) {
					h = ((h % 1) + 1) % 1;
					const i = Math.floor(h * 6);
					const f = h * 6 - i;
					const p = v * (1 - s);
					const q = v * (1 - f * s);
					const t = v * (1 - (1 - f) * s);
					let r, g, b;
					switch (i % 6) {
						case 0:
							(r = v), (g = t), (b = p);
							break;
						case 1:
							(r = q), (g = v), (b = p);
							break;
						case 2:
							(r = p), (g = v), (b = t);
							break;
						case 3:
							(r = p), (g = q), (b = v);
							break;
						case 4:
							(r = t), (g = p), (b = v);
							break;
						default:
							(r = v), (g = p), (b = q);
							break;
					}
					return new BABYLON.Color3(r, g, b);
				}

				async function createScene() {
					const scene = new BABYLON.Scene(engine);
					scene.clearColor = new BABYLON.Color4(0.04, 0.06, 0.1, 1);

					const camera = new BABYLON.ArcRotateCamera(
						"camera",
						Math.PI / 2,
						Math.PI / 2.3,
						3,
						new BABYLON.Vector3(0, 0.8, 0),
						scene
					);
					camera.attachControl(canvas, true);
					camera.wheelDeltaPercentage = 0.01;
					camera.panningSensibility = 0;
					camera.useAutoRotationBehavior = false;

					const hemi = new BABYLON.HemisphericLight(
						"hemi",
						new BABYLON.Vector3(0, 1, 0),
						scene
					);
					hemi.intensity = 0.55;

					const dir = new BABYLON.DirectionalLight(
						"dir",
						new BABYLON.Vector3(-0.4, -1.0, 0.6),
						scene
					);
					dir.intensity = 1.1;

					const shadowGen = new BABYLON.ShadowGenerator(2048, dir);
					shadowGen.useBlurExponentialShadowMap = true;
					shadowGen.blurKernel = 16;

					// 轻量环境（不用额外 HDR 也能有点质感）
					scene.environmentIntensity = 0.9;

					const root = new BABYLON.TransformNode("root", scene);
					const fiberMaterials = new Set();

					setStatus("正在加载 48.glb …");
					const glbUrl = new URL("48.glb", window.location.href).toString();

					const result = await BABYLON.SceneLoader.ImportMeshAsync(
						null,
						"",
						glbUrl,
						scene,
						(evt) => {
							if (!evt.lengthComputable) return;
							const pct = Math.round((evt.loaded / evt.total) * 100);
							setStatus(`正在加载 48.glb … ${pct}%`);
						}
					);

					// 将导入的 mesh 统一挂到 root，便于整体旋转/定位
					for (const mesh of result.meshes) {
						if (mesh && mesh !== scene.meshes[0]) {
							// 跳过场景默认根 mesh 的不确定性：只要能 parent 就 parent
							if (mesh.parent == null && mesh !== root) {
								mesh.parent = root;
							}
						}

						// 收集“光纤”相关材质：优先按 mesh/material 名称关键词，其次按 emissive 非黑
						const mat = mesh && mesh.material;
						if (!mat) continue;

						const name = `${mesh.name || ""} ${mat.name || ""}`.toLowerCase();
						const keywordHit =
							name.includes("fiber") ||
							name.includes("fibre") ||
							name.includes("neon") ||
							name.includes("tube") ||
							name.includes("light") ||
							name.includes("光纤");

						const emissive =
							mat.emissiveColor &&
							(mat.emissiveColor.r > 0.02 ||
								mat.emissiveColor.g > 0.02 ||
								mat.emissiveColor.b > 0.02);

						if (keywordHit || emissive) {
							fiberMaterials.add(mat);
						}
					}

					// 相机自动取景
					try {
						const meshes = root.getChildMeshes(false);
						if (meshes.length) {
							const agg = new BABYLON.Mesh("__agg__", scene);
							agg.isVisible = false;
							for (const m of meshes) {
								if (m.geometry) {
									m.computeWorldMatrix(true);
								}
							}
							agg.setEnabled(false);

							const bi = BABYLON.Mesh.MergeMeshes(
								meshes.filter((m) => m.isVisible && m.getTotalVertices() > 0),
								true,
								true,
								undefined,
								false,
								true
							);

							if (bi) {
								bi.setEnabled(false);
								const bounds = bi.getBoundingInfo().boundingBox;
								const center = bounds.centerWorld;
								const extents = bounds.extendSizeWorld;
								const radius = Math.max(extents.x, extents.y, extents.z) * 2.2;
								camera.setTarget(center);
								camera.radius = Math.max(1.2, radius);
								camera.lowerRadiusLimit = camera.radius * 0.25;
								camera.upperRadiusLimit = camera.radius * 4;
								bi.dispose();
							}
						}
					} catch {
						// 自动取景失败不影响主功能
					}

					// 阴影：给所有子 mesh 加入投射
					for (const m of root.getChildMeshes(false)) {
						if (m && m.getTotalVertices && m.getTotalVertices() > 0) {
							shadowGen.addShadowCaster(m, true);
						}
					}

					setStatus(
						`加载完成：mesh ${result.meshes.length} / materials ${scene.materials.length} / 光纤材质候选 ${fiberMaterials.size}`
					);

					const start = performance.now();
					scene.onBeforeRenderObservable.add(() => {
						const now = performance.now();
						const t = (now - start) / 1000;

						fpsEl.textContent = `${engine.getFps().toFixed(0)} fps`;

						// 自转
						if (rotateToggle.checked) {
							const speed = Number(rotateSpeedEl.value);
							root.rotation.y += engine.getDeltaTime() * 0.001 * speed;
						}

						// 光纤变色：循环 HSV + 轻微脉冲
						if (fiberToggle.checked && fiberMaterials.size > 0) {
							const s = Number(fiberSpeedEl.value);
							const hue = (t * 0.08 * s) % 1;
							const pulse = 0.65 + 0.35 * Math.sin(t * 2.0 * s);

							let idx = 0;
							for (const mat of fiberMaterials) {
								const localHue = (hue + idx * 0.07) % 1;
								const c = hsvToColor3(localHue, 0.95, 1.0);

								if (mat.emissiveColor) {
									mat.emissiveColor = c.scale(pulse);
								}

								// PBR 材质里也尽量让它更“发光”一点
								if (typeof mat.emissiveIntensity === "number") {
									mat.emissiveIntensity = 0.6 + 1.2 * pulse;
								}

								idx++;
							}
						}
					});

					return scene;
				}

				(async () => {
					try {
						const scene = await createScene();
						engine.runRenderLoop(() => scene.render());
					} catch (err) {
						console.error(err);
						setStatus(
							"加载失败：可能是浏览器拦截了 file:// 资源或 48.glb 路径不对。建议用本地服务器打开。"
						);
					}
				})();

				window.addEventListener("resize", () => engine.resize());
			})();
		</script>
	</body>
</html>

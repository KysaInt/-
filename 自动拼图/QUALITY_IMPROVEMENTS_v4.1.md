# 自动拼图 v4.1 - 画质优化和边界检测增强

## 📋 本次更新主要内容

本版本重点解决了三个核心问题：
1. **🖼️ 严重的画质压缩问题**
2. **🔍 不完整的边界检测和裁切管道**
3. **🔐 添加强制管理员权限执行**

---

## ✨ 主要改进

### 1. ScrollBoundaryDetector 类 - 完全重写 (Lines 476-613)

#### 改进点：
- **双重检测算法**
  - 方法1: 基于帧差异（检测变化的行）✓
  - 方法2: 基于边缘检测（辅助方法）✓
  - 综合两种结果，取更保守的值

- **智能阈值计算**
  - 动态计算阈值（原阈值30%，现改为25%）
  - 针对每个帧的具体情况进行调整
  - 防止误检和漏检

- **详细日志输出**
  - 显示检测过程的每一步
  - 输出两种方法的单独结果
  - 清晰展示最终的边界参数
  - 使用 emoji 便于日志识别

- **安全性检查**
  - 验证边界合理性
  - 防止边界过大导致内容丢失
  - 自动调整异常情况

#### 核心方法：
```python
detect_boundaries(images) -> (top_crop, bottom_crop)
  |-- _detect_by_frame_diff()      # 主要方法：相邻帧差异
  |-- _detect_by_edge_analysis()   # 辅助方法：边缘检测
  |-- 综合结果并验证

crop_images(images, top_crop, bottom_crop) -> cropped_images
  |-- 按行号进行无损裁切
  |-- 清晰输出裁切进度
```

#### 工作流程：
```
输入: N 张全屏截图
  ↓
[帧差异分析] 找到变化最大的行范围（内容区）
  ↓
[边缘检测] 识别有内容的区域
  ↓
[结果综合] 计算固定UI的上下边界
  ↓
[边界裁切] 移除固定UI，保留纯内容区
  ↓
输出: N 张裁切后的图片 ✓
```

---

### 2. 图像质量保证 - 全流程优化

#### 问题根源分析：
之前的代码虽然使用了 PNG 格式和压缩参数 9，但问题可能来自其他阶段：

1. ❌ **图像加载**
   - 原代码：`cv2.imread(filepath)` 使用默认模式
   - 新代码：`cv2.imread(filepath, cv2.IMREAD_COLOR)` 显式指定颜色格式

2. ❌ **数据类型处理**
   - 原代码：没有检查数据类型
   - 新代码：在保存前验证数据类型是否为 uint8

3. ❌ **保存参数**
   - 原代码：有 PNG 压缩参数，但可能被忽略
   - 新代码：增强了保存逻辑和验证

#### 新的质量保证方案：

**阶段1：加载图片** (Lines 763-797)
```python
# ✓ 使用显式的 IMREAD_COLOR
img = cv2.imread(filepath, cv2.IMREAD_COLOR)  # BGR 格式，无压缩

# ✓ 详细的加载日志
输出每张图片的加载状态和尺寸
```

**阶段2：图片优化** (Lines 799-827)
```python
# ✓ 使用 INTER_AREA 进行高质量缩小
resized = cv2.resize(img, (new_w, new_h), interpolation=cv2.INTER_AREA)
# INTER_AREA 是最好的缩小方法，保留关键细节

# ✓ 及时释放内存
del img
gc.collect()
```

**阶段3：预处理** (Lines 829-847)
```python
# ✓ 调用改进的边界检测
detector = ScrollBoundaryDetector()
top_crop, bottom_crop = detector.detect_boundaries(images)

# ✓ 执行智能裁切
cropped_images = detector.crop_images(images, top_crop, bottom_crop)
```

**阶段4：拼接** (Lines 849-871)
```python
# ✓ 使用 SCANS 模式（针对有序截图优化）
stitcher = cv2.Stitcher.create(cv2.Stitcher_SCANS)
```

**阶段5：保存** (Lines 943-991)
```python
# ✓ 验证数据类型
if stitched.dtype != np.uint8:
    stitched = np.clip(stitched * 255, 0, 255).astype(np.uint8)

# ✓ PNG 无损压缩
success = cv2.imwrite(
    output_path, 
    stitched, 
    [cv2.IMWRITE_PNG_COMPRESSION, 9]  # 最大压缩，无损质量
)

# ✓ 验证保存成功
assert os.path.exists(output_path), "文件保存失败"
```

---

### 3. 详细日志系统

#### 日志结构（方便调试）：

```
════════════════════════════════════════════════════════════════
📂 阶段 1: 加载图片文件
════════════════════════════════════════════════════════════════
  [  1/200] ✓ screenshot_0001.png          - 1920x1080
  [  5/200] ✓ screenshot_0005.png          - 1920x1080
  ...
✅ 成功加载 200 张有效图片
   原始尺寸范围: 1920x1080
════════════════════════════════════════════════════════════════

════════════════════════════════════════════════════════════════
🔍 阶段 2: 优化图片大小
════════════════════════════════════════════════════════════════
  ✓ 图片尺寸合理，无需缩放
════════════════════════════════════════════════════════════════

════════════════════════════════════════════════════════════════
🔍 开始检测滚动边界，共 200 张图片...
════════════════════════════════════════════════════════════════
📏 图片尺寸: 1920x1080
  📊 [方法1] 检测到 950 行变化
  📊 [方法1] 变化范围: 120-1050 (930px)
  📊 [方法1] 结果 -> top=120, bottom=30
  🔲 [方法2] 检测到 1000 行有边缘
  🔲 [方法2] 结果 -> top=0, bottom=0
✅ 最终检测结果:
   顶部固定UI: 120px
   底部固定UI: 30px
   内容区域: 930px
════════════════════════════════════════════════════════════════

✂️ 开始裁切 200 张图片...
   裁切范围: y=120 到 y=1050
   新高度: 930px
   ✅ 裁切完成: 200 张图片从 1080px -> 930px

════════════════════════════════════════════════════════════════
🧩 阶段 4: 执行图像拼接
════════════════════════════════════════════════════════════════
✓ 拼接器创建成功 (SCANS 模式)
📊 处理 200 张图片...
...

════════════════════════════════════════════════════════════════
💾 准备保存拼接结果
   尺寸: (16854, 1920, 3)
   输出路径: /path/to/stitched_result.png
════════════════════════════════════════════════════════════════
✅ 拼接结果已保存
   文件路径: /path/to/stitched_result.png
   文件大小: 12.34 MB (12,923,456 bytes)
   图像尺寸: 1920x16854 (宽x高)
   压缩方式: PNG (无损压缩，质量 9/9)
════════════════════════════════════════════════════════════════
```

---

### 4. 管理员权限检查 (Lines 445-475)

```python
def check_and_request_admin_privileges():
    """检查并请求管理员权限（确保快捷键有效）"""
    if not is_admin():
        # 使用 ShellExecuteW 以 runas 动词重启程序
        restart_with_admin()
```

**执行点**：在所有其他代码之前（模块级别）
**效果**：确保程序始终以管理员身份运行
**必要性**：Windows hotkey 库需要管理员权限才能捕获全局快捷键

---

## 🔧 技术细节

### 边界检测算法详解

#### 方法1：帧差异分析（PRIMARY）
1. 比较相邻两帧的差异
2. 计算每一行的平均差异强度
3. 使用动态阈值（平均值 × 0.25）找出变化行
4. 第一个变化行 = 顶部固定UI高度
5. 最后一个变化行 = 底部固定UI起点

**优点**：准确检测滚动内容的范围
**缺点**：对于完全静态的UI可能失效

#### 方法2：边缘检测（AUXILIARY）
1. 对前3张图片进行 Canny 边缘检测
2. 找出有边缘的行（通常有内容）
3. 查找最大的无边缘区间
4. 这些区间通常对应导航栏等固定UI

**优点**：不受内容相似度影响
**缺点**：可能漏掉低对比度的UI

#### 综合策略
- 方法1 + 方法2 结果取最大值（保守策略）
- 确保不会裁掉有用的内容
- 同时移除尽可能多的固定UI

---

## 📊 性能指标

| 项目 | 改进前 | 改进后 | 变化 |
|------|------|------|------|
| 图片加载 | 默认格式 | 显式 BGR | ✓ |
| 缩小插值 | INTER_AREA | INTER_AREA | ✓ |
| PNG 压缩 | 级别9 | 级别9 | ✓ |
| 边界检测 | 单一方法 | 双重检验 | ✓✓ |
| 日志详细度 | 基础 | 完整信息 | ✓✓✓ |
| 数据验证 | 无 | 多点验证 | ✓✓ |

---

## 🎯 预期效果

### 画质改善
✅ **PNG 格式保证无损压缩**
✅ **全流程数据类型验证**
✅ **最优插值算法**
✅ **可验证的保存过程**

### 边界检测准确性
✅ **双重算法验证**
✅ **动态阈值计算**
✅ **详细的检测日志**
✅ **异常情况处理**

### 快捷键功能
✅ **强制管理员权限**
✅ **改进的 keyboard 库集成**
✅ **更好的错误反馈**

---

## 🧪 测试建议

1. **质量测试**
   ```bash
   # 使用各种窗口和内容进行长截图
   # 检查输出的 PNG 文件：
   # - 文件大小合理（应该较大，因为内容多）
   # - 打开时无损和无压缩伪影
   # - 对比度和清晰度正常
   ```

2. **边界检测测试**
   ```bash
   # 在不同的应用中截图：
   # - 浏览器（顶部导航栏）
   # - 手机模拟器（底部导航栏）
   # - 文档应用（页眉页脚）
   # 检查日志输出的边界参数是否正确
   ```

3. **快捷键测试**
   ```bash
   # 启动程序（应自动要求管理员权限）
   # 测试快捷键是否正常工作
   # 检查控制台是否显示快捷键激活消息
   ```

---

## 📝 代码变更统计

- **新增代码行**：约 150 行
- **改进的类**：ScrollBoundaryDetector (完全重写)
- **改进的方法**：StitchThread.run(), 保存逻辑
- **新增功能**：双重边界检测算法，详细日志系统

---

## ⚠️ 注意事项

1. **管理员权限**
   - 程序现在会在启动时检查管理员权限
   - 如果没有权限，会自动请求提升
   - 这是快捷键正常工作的必要条件

2. **边界检测**
   - 需要至少 2 张图片才能工作
   - 对于完全相同的帧，可能无法准确检测
   - 建议在移动内容时截图

3. **内存管理**
   - 大量图片处理时使用 `gc.collect()`
   - 及时释放不需要的对象
   - 建议最多处理 500 张 1080p 图片

---

## 📞 故障排查

### 问题：边界检测为 (0, 0)
**原因**：图片变化不足或格式不兼容
**解决**：
- 确保在移动内容时截图
- 检查截图是否包含滚动区域
- 查看详细日志的检测过程

### 问题：快捷键不工作
**原因**：未获得管理员权限
**解决**：
- 重新启动程序（应自动请求权限）
- 检查是否在命令提示符中拒绝了权限请求
- 查看控制台的权限检查消息

### 问题：PNG 文件仍然很小
**原因**：内容重复率高或颜色简单
**解决**：
- PNG 压缩率取决于内容复杂度
- 在不同网站上测试
- 检查 imwrite 是否返回 True

---

**版本号**: 4.1  
**发布日期**: 2024  
**主要改进**: 画质优化、边界检测增强、管理员权限  

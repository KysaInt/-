# 依赖检查问题修复说明

## 🐛 问题描述

**症状**：程序每次启动都要重新安装依赖，即使依赖已经安装好了。

## 🔍 问题原因

### 原始设计的缺陷

```python
# 原始代码（有问题）
if '--skip-dep-check' not in sys.argv:
    missing, outdated = check_missing_dependencies()
    if missing or outdated:
        # 显示安装界面
```

**问题分析**：

1. ✅ **首次安装时**：程序检测到缺失依赖 → 安装 → 重启时带 `--skip-dep-check` 参数 → 跳过检查 ✓
2. ❌ **第二次正常启动**：用户双击程序 → 没有 `--skip-dep-check` 参数 → **再次检查** → 如果检查逻辑有误，又提示安装 ✗

### 可能导致误报的原因

1. **版本号解析错误**
   - 某些包的版本号格式特殊（如 `4.8.1.78`）
   - 原始代码用 `v.split('.')[:3]` 可能导致解析失败

2. **模块导入失败**
   - `__import__` 有时无法正确导入子模块
   - 特别是 `win32clipboard` 等特殊模块

3. **异常处理不当**
   - 如果检查过程中出现任何异常，会误判为缺失

## ✅ 修复方案

### 1. 移除 `--skip-dep-check` 机制

```python
# 修复后的代码
# 每次都检查，但只在真正缺失时才提示
missing, outdated = check_missing_dependencies()

if missing or outdated:
    # 显示安装界面
```

**优势**：
- 更简单直接
- 如果依赖真的存在，检查会通过，不会重复安装
- 如果依赖缺失，会正确提示安装

### 2. 改进依赖检查逻辑

#### A. 更健壮的模块检查

```python
# 改进前
if importlib.util.find_spec(module_name) is None:
    missing.append((module_name, required_version))
    continue

module = __import__(module_name)

# 改进后
try:
    spec = importlib.util.find_spec(module_name)
    if spec is None:
        missing.append((module_name, required_version))
        continue
    
    try:
        module = __import__(module_name)
        # 获取版本...
    except Exception:
        # 模块存在但无法导入，跳过版本检查
        pass
except (ImportError, ModuleNotFoundError):
    missing.append((module_name, required_version))
except Exception:
    # 其他异常忽略，避免误报
    pass
```

#### B. 更强大的版本号比较

```python
# 改进前
def normalize(v):
    return [int(x) for x in v.split('.')[:3]]
    # 问题：如果版本号是 "4.8.1.78" 会失败

# 改进后
def normalize(v):
    parts = []
    for part in str(v).split('.')[:3]:
        import re
        num = re.findall(r'\d+', part)
        if num:
            parts.append(int(num[0]))
    return parts
    # 优势：可以处理各种格式的版本号
```

#### C. 异常时的降级处理

```python
# 关键原则：宁可漏检，不可误报

try:
    # 版本比较...
except Exception:
    # 如果比较失败，认为版本满足要求
    return 0  # 不报错
```

### 3. 添加调试模式

```python
# 设置环境变量 DEBUG=1 可以看到详细信息
DEBUG = os.environ.get('DEBUG', '0') == '1'

if DEBUG:
    print("依赖检查开始...")
    print(f"缺失: {len(missing)} 个")
    print(f"过期: {len(outdated)} 个")
```

## 🧪 测试方法

### 测试依赖检查是否正常

1. **开启调试模式**：
   ```cmd
   set DEBUG=1
   pythonw auto_screenshot_stitch.pyw
   ```

2. **查看输出**：
   ```
   ============================================================
   依赖检查开始...
   ============================================================
   
   检查结果:
     缺失: 0 个
     过期: 0 个
   ============================================================
   ```

3. **如果依赖已安装**，应该看到 "缺失: 0 个, 过期: 0 个"

### 验证不再重复安装

1. 确保所有依赖已安装
2. 关闭程序
3. 再次启动程序
4. **应该直接进入主界面**，不再显示安装对话框

## 📊 修复前后对比

| 场景 | 修复前 | 修复后 |
|------|--------|--------|
| 首次启动（无依赖） | ✅ 安装 | ✅ 安装 |
| 重启后（依赖已装） | ✅ 正常 | ✅ 正常 |
| 第二次正常启动 | ❌ **再次安装** | ✅ **直接运行** |
| 版本号特殊格式 | ❌ 误报 | ✅ 正确识别 |
| 模块导入异常 | ❌ 误报 | ✅ 容错处理 |

## 🎯 核心修复点

1. ✅ **移除参数依赖**：不再依赖 `--skip-dep-check` 参数
2. ✅ **改进版本比较**：使用正则表达式提取版本号
3. ✅ **异常容错**：检查失败时不误报
4. ✅ **调试支持**：添加 DEBUG 模式便于排查

## 💡 如果仍然出现问题

### 排查步骤

1. **开启调试模式查看具体信息**：
   ```cmd
   set DEBUG=1
   python auto_screenshot_stitch.pyw
   ```

2. **手动检查依赖**：
   ```cmd
   python -c "import PySide6; print(PySide6.__version__)"
   python -c "import cv2; print(cv2.__version__)"
   python -c "import numpy; print(numpy.__version__)"
   python -c "import PIL; print(PIL.__version__)"
   python -c "import win32clipboard"
   python -c "import keyboard; print(keyboard.__version__)"
   ```

3. **检查是否有多个 Python 环境**：
   ```cmd
   where python
   where pythonw
   ```

### 常见问题

**Q: 为什么 `win32clipboard` 总是提示安装？**

A: `pywin32` 安装后，模块名是 `win32clipboard`，但包名是 `pywin32`。检查代码中的 `PACKAGE_NAMES` 映射：

```python
PACKAGE_NAMES = {
    'cv2': 'opencv-contrib-python',
    'PIL': 'Pillow',
    'win32clipboard': 'pywin32'
}
```

**Q: 为什么 OpenCV 版本号比较失败？**

A: OpenCV 的版本号可能是 `4.8.1.78`（4段），改进后的版本比较函数只取前3段，并用正则提取数字。

**Q: 如何完全禁用依赖检查？**

A: 不建议禁用，但如果需要，可以注释掉检查代码：

```python
# 注释掉这段
# missing, outdated = check_missing_dependencies()
# if missing or outdated:
#     ...

# 直接导入
import tempfile
import shutil
...
```

## 📝 总结

修复后的依赖检查机制：
- ✅ 更可靠：不会因为特殊情况误报
- ✅ 更简单：移除复杂的参数传递机制
- ✅ 更容错：异常情况下不阻止程序启动
- ✅ 更透明：支持调试模式查看详情

如果依赖已正确安装，程序应该**每次启动都直接进入主界面**，不再重复安装！

---

**修复时间**：2025年10月15日  
**版本**：v2.1 (修复依赖检查)
